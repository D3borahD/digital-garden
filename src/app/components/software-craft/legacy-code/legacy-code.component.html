<h2>Travailler avec du code legacy</h2>

<p>Le code legacy est un code qui ne dispose pas de tests.</p>

<h3>1. Apprivoiser le code legacy</h3>

<!--TODO : graph -->
<div class="graph ">
    <div class="box-graph pink-purple">
        <p>Avoir le bon état d'esprit</p>
    </div>
    <i class="fa-solid fa-arrow-down"></i>
    <div class="box-graph pink-purple">
        <p>Réaliser un état des lieux</p>
    </div>
    <div class="box-graph pink-purple">
        <p>Présence de tests ?</p>
    </div>
    <div class="d-flex">
        <div class="box-graph pink-purple">
            <p>Enrichir les tests</p>
        </div>
        <div class="box-graph pink-purple">
            <p>Le code est-il testable ?</p>
        </div>
    </div>
</div>

<h4>1.1 Méthodologie globale</h4>

<h4>1.2 Adopter le bon état d'esprit</h4>
<ul>
    <li><span class="pink-purple-txt">Garder son calme.</span></li>
    <li><span class="pink-purple-txt">Rester focus.</span>
        <p>Si l'application n'a pas besoin d'évoluer, le code existant est certainement suffisant pour tourner en
            production.</p>
        <p><span class="pink-purple-txt">Question à se poser : </span>quel objectif on poursuit ?</p>
        <ul>
            <li>Fournir une évolution ?</li>
            <li>Corriger une anomalie ?</li>
            <li>Réduire un aspect de dette technique encombrant pour des fonctionnalités à venir ?</li>
        </ul>
        <p>Le remaniement de code legacy étant risqué et onéreux, il est important de se concentrer sur les réécritures
        <span class="pink-purple-txt">qui apportent une réelle valeur.</span></p>
        <p>Rester focalisé sur un problème à la fois, procéder par petites itérations.</p>
    </li>
</ul>

<h4>1.3 S'imprégner du code</h4>
<p>Faire un état des lieux.</p>
<ul>
    <li><span class="pink-purple-txt">Le code est-il exécutable ?</span>
        <p>Quels sont les moyens d'intéragir avec l'application et d'observer les effets ?</p>
        <p>Une documentation est-elle fournie ?</p>
    </li>
    <li><span class="pink-purple-txt">Des tests sont-ils présents ?</span>
        <p>Peut-on lancer les tests ? Sont-ils annotés ignorés ou commentés ? Ce sont de vrais tests, avec assertions
            sensées ?</p>
        <p>Quand les tests peuvent-être exécutés, certains passent, d'autres non.</p>
        <p>Pour les tests qui ne passent pas, on ne peut pas en déterminer grand chose, il faudra probablement prendre
        la décision de les jeter. Ils ne sont plus en phase avec la réalité du code.</p>
    </li>
    <li><span class="pink-purple-txt">Se faire une idée générale du code.</span>
        <p>Identifier le périmètre d'intervention sur le code.</p>
        <p>Recenser les structures de données, les concepts qui sont manipulés, pour commencer à construire un modèle
        mental.</p>
        <p>Noter ce qui ne va pas, amélioration et refactoring à prévoir. S'entraîner à remarquer les patterns (des if
        qui reviennent souvent), repérer la duplication. Sans toucher au code. On peut éventuellement mettre des TODO et
        FIXME</p>
    </li>
    <li><span class="pink-purple-txt">Écrire les tests qui manquent.</span></li>
</ul>

<h3>2. Tester le code legacy</h3>

<h4>Poser un premier test</h4>
<app-callout-section title="Citation">
  <p>"Ce qui est important n'est pas ce que le code est supposé faire mais ce qu'il fait vraiment."</p>
  <p>Arnaud Lemaire <a href="https://www.youtube.com/live/LSqbXorkyfQ?si=W2TRPdEVJC4AUWbP">Youtube tutorial : kata trip
  Service.</a></p>
</app-callout-section>

<p>Contrairement au TDD, dans le code legacy, c'est au code de test de se conformer au comportement du code de production.</p>

<h4>Approche par compréhension du code</h4>
<p>Face à un code plutôt clair, on peut essayer d'identifier les règles de gestion qui serviront de fondation aux tests.</p>
<app-callout-section title="Conseil">
  <P>Tester en premier les branches les moins profondes du code (les plus directement accessibles), refactorer en premier
    les branches les plus profondes.</P>
</app-callout-section>

<pre>
  <span class="label">c#</span>
  <code class="c#">
    public List&lt;Trip&gt; getTripsByUser(User user) throws UserNotLeggedInException &#123;
      List&lt;Trip&gt; tripList = new ArrayList&lt;Trip&gt;();
      User loggedUser = UserSession.getInstance().getLoggedUser();
      boolean isFriend = false;
      if(loggedUser != null) &#123;
        // ...
      &#125; else &#123;
      throw new UserNotLoggedInException();
      &#125;
    &#125;
  </code>
</pre>

<p>On remarque que la ligne "isFriend" n'est pas utilisé à ce niveau, c'est une indication que  le scope de définition
de cette variable est certainement trop large (la déplacer à l'intérieur du bloc if serait plus pertinent).</p>

<h4>Approche par observation du code</h4>
<p>Le code est trop énigmatique, on se tourne vers une approche "boîte noire", en stimulant le code, c'est-à-dire qu'on
  le force à produire un comportement et en capturant son comportement réel.</p>
<a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Kata Gilded Rose</a>

<ul>
  <li><span class="pink-purple-txt">Construction d'un golden master</span> : Avec un code si cryptique, il est nécessaire
  de partir sur une approche contre-intuitive. Il faut se baser sur l'idée que le code tourne en production, fait ce qui
  est attendu et représente donc un vérité absolue. On va chercher à observer et tracer son comportement. Pour cela on
  va stimuler le code et enregistrer les effets produits (par exemple dans un fichier de référence). C'est cet enregistrement
  qu'on désigne par le terme de <span class="pink-purple-txt">golden master</span>.
  <p>Le golder master est comme une forme de tests de caractérisation, c'est-à-dire, des tests qui appellent le code
  existant sans le modifier pour observer comment il se comporte. Le golden master enregistre tous les résultats attendus
  pour chacun des jeux de valeur en entrée.</p>
  <p>Plus il est étoffé, plus il offre un filet de sécurité efficace contre d'éventuelles régressions.</p></li>
  <li><span class="pink-purple-txt">Choix des données de test en entrée.</span></li>
  <li><span class="pink-purple-txt">Construction itérative du golder master.</span></li>
</ul>

<p>Parfois, il est nécessaire au préalable de réorganiser le code de production.</p>

<p>en cours ... </p>

<h3>3. Rendre testable le code legacy</h3>

<h3>4. Refactorer le code legacy</h3>

<h3>5. L'approche Scratch refactoring</h3>

<h3>6. L'approche d'amélioration marginale</h3>

<h3>Conclusion</h3>

<p>En cours ... </p>
