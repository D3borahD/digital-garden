<h2>Les services</h2>
<p>Ils permettent de :</p>
<ul>
  <li>mieux organiser l'application</li>
  <li>√©viter de se r√©p√©ter</li>
  <li>avoir toujours des donn√©es √† jour</li>
  <li>centraliser les donn√©es</li>
</ul>

<p>G√©n√©rer un service : </p>
<pre>
   <label class="label">BASH</label>
  <code>
    ng g s nom-de-mon-service
  </code>
</pre>

<p>Un service est une class, pour le d√©clarer on utilise le d√©corateur &#64;Injectable()</p>

<pre>
  <label class="label">TS</label>
  <code>
    import &#123; Injectable &#125; from '&#64;angular/core';

    // d√©corateur
    &#64;Injectable(&#123;
        // permet d'enregistrer le service √† la racine du projet.
        providedIn: 'root'
    &#125;)
    export class PostsService &#123;

        constructor() &#123; &#125;
    &#125;
  </code>
</pre>

<p>Les services n'ont pas de m√©thode ngOnInit() car ils ne sont pas instanti√©s de la m√™me mani√®re que les composants.</p>
<p>Pour utiliser un service dans un component, il faut utiliser le syst√®me d'injection de d√©pendances fournit par Angular.</p>
<p>Il faut passer un argument du type service au constructor du component, Angular met √† disposition la bonne instance du service</p>


<pre>
  <label class="label">TS</label>
  <code>
    import &#123;PostsService&#125; from "../../services/posts.service";
    //...
    export class PostListComponent implements OnInit &#123;

      public posts!: PostModel[];

      constructor(
      // ajouter un modificateur d"acc√®s (private) √† un argument du constructor cr√©e une propri√©t√© avec ce nom dans la classe. On a donc acc√®s au service via la propri√©t√© PostsService
        private postsService: PostsService
      )
    &#123; &#125;

    ngOnInit(): void  &#123;
      this.posts = this.postsService.posts
    &#125;
  </code>
</pre>

<div class="definition">
  <i></i>
  <p>On pr√©f√®re "private" pour les injections de service, car √ßa emp√™che le template du component d'y acc√©der directement.</p>
  <p>Donner au template un acc√®s aux injections serait un anti-pattern Angular.</p>
</div>

<pre>
  <label class="label">service.TS</label>
  <code>
    // cr√©ation d'une m√©thode
    // ne pas oublier de pr√©ciser le type de retour (: PostModel[])
    public getAllPosts(): PostModel[]&#123;
      return this.posts
    &#125;

    public  getPostById(postId:number): PostModel &#123;
      const post = this.posts.find(post => post.id === postId)
      if (!post)&#123;
        throw new Error('Post not found')
      &#125; else &#123;
        return post
      &#125;
    &#125;

    // ici on utilise un literal type
    public likePostById(postId:number, isLiked: 'like' | 'unlike'): void &#123;
      const post = this.getPostById(postId)
      isLiked ==='like' ? post.like++ : post.like--
    &#125;
  </code>
</pre>

<pre>
  <label class="label">TS</label>
  <code>
    ngOnInit(): void &#123;
      // utilisation de la m√©thode
      this.posts = this.postsService.getAllPosts()
    &#125;
  </code>
</pre>

<pre>
  <label class="file-name">üìÑ post.component.ts</label>
  <code>
    onLike() &#123;
    if(this.liked === false) &#123;
      this.postService.likePostById(this.post.id, 'like')
      this.liked = true
    &#125; else &#123;
      this.postService.likePostById(this.post.id, 'unlike')
      this.liked = false
    &#125;
  &#125;
  </code>
</pre>

<div class="definition">
  <p>Ce genre d'architecture <span class="pink-purple-txt">modulaire</span> est l'un des gros points forts d'Angular</p>
</div>



